{"version":3,"file":"node_modules_astrouxds_astro-web-components_dist_esm_rux-segmented-button_entry_js.node_modules_astrouxds_astro-web-components_dist_esm_rux-segmented-button_entry_js.js","mappings":";;;;;;;;;;;;;;AAAkG;;AAElG,qCAAqC,cAAc,uBAAuB,qBAAqB,mBAAmB,sBAAsB,oBAAoB,iBAAiB,gBAAgB,UAAU,SAAS,gBAAgB,yCAAyC,uDAAuD,+BAA+B,iBAAiB,WAAW,SAAS,UAAU,qCAAqC,aAAa,uBAAuB,mBAAmB,WAAW,iBAAiB,SAAS,kBAAkB,mDAAmD,sCAAsC,uDAAuD,eAAe,yBAAyB,sBAAsB,qBAAqB,iBAAiB,qCAAqC,wBAAwB,2CAA2C,4DAA4D,oDAAoD,2CAA2C,aAAa,mDAAmD,+DAA+D,8CAA8C,yDAAyD,oEAAoE,mDAAmD,4DAA4D,mEAAmE,kBAAkB,iBAAiB,iDAAiD,wEAAwE,gDAAgD,wEAAwE,kCAAkC,yCAAyC,2CAA2C,gBAAgB,YAAY,YAAY,yDAAyD;;AAE/9D;AACA;AACA,IAAI,qDAAgB;AACpB,qBAAqB,qDAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qDAAC,SAAS,+BAA+B,2BAA2B,qDAAC,SAAS,wCAAwC,EAAE,qDAAC,YAAY,mLAAmL,GAAG,qDAAC,YAAY,oCAAoC;AACxX;AACA,aAAa,OAAO,qDAAU;AAC9B,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEsD","sources":["webpack://svelte-app/./node_modules/@astrouxds/astro-web-components/dist/esm/rux-segmented-button.entry.js"],"sourcesContent":["import { r as registerInstance, c as createEvent, h, g as getElement } from './index-cf8aeed9.js';\n\nconst ruxSegmentedButtonCss = \":host{display:block;box-sizing:border-box;}*,*::before,*::after{box-sizing:inherit}.rux-segmented-button{display:inline-flex;height:1.6875rem;overflow:hidden;padding:0;margin:0;list-style:none;border-radius:var(--controlBorderRadius);background-color:var(--segmentedButtonBackgroundColor)}.rux-segmented-button__segment{height:1.6875rem;width:auto;margin:0;padding:0}.rux-segmented-button__segment label{display:flex;justify-content:center;align-items:center;width:auto;height:1.5625rem;margin:0;padding:0 0.75rem;border:1px solid var(--segmentedButtonBorderColor);color:var(--segmentedButtonTextColor);background-color:var(--segmentedButtonBackgroundColor);font-size:1rem;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.rux-segmented-button__segment input{display:none !important}.rux-segmented-button__segment label:hover{background-color:var(--segmentedButtonHoverBackgroundColor);border-color:var(--segmentedButtonHoverBorderColor);color:var(--segmentedButtonHoverTextColor);outline:none}.rux-segmented-button__segment input:checked+label{background-color:var(--segmentedButtonSelectedBackgroundColor);color:var(--segmentedButtonSelectedTextColor)}.rux-segmented-button__segment input:checked:hover+label{background-color:var(--segmentedButtonSelectedHoverBackgroundColor);color:var(--segmentedButtonSelectedHoverTextColor);border-color:var(--segmentedButtonSelectedHoverBorderColor)}.rux-segmented-button__segment:nth-child(2):not(:last-child) label{border-right:none;border-left:none}.rux-segmented-button__segment:first-child label{border-radius:var(--controlBorderRadius) 0 0 var(--controlBorderRadius)}.rux-segmented-button__segment:last-child label{border-radius:0 var(--controlBorderRadius) var(--controlBorderRadius) 0}.rux-segmented-button.style-scope{border-radius:3px 6px 6px 3px !important}.rux-segmented-button__segment.style-scope{border-radius:0;height:auto;border:none;border-right:1px solid var(--segmentedButtonBorderColor)}\";\n\nconst RuxSegmentedButton = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.ruxChange = createEvent(this, \"rux-change\", 7);\n    /**\n     * Items in this Array are the individual button segments.\n     */\n    this.data = [];\n    /**\n     * When passed in on load, this selects the first button segment with a matching label. When the selected segment changes, this property updates with the currently selected value, which reflects back to the component attribute. If no button segment label matches this string, then no segment is selected. This value takes priority over setting selected boolean property on the items in the data array.\n     */\n    this.selected = '';\n  }\n  onDataChange(newValue) {\n    if (newValue) {\n      const initialSelection = this.data.find((segment) => segment.selected);\n      if (initialSelection) {\n        this._setSelected(initialSelection.label);\n      }\n      else {\n        if (!this.selected) {\n          this._setSelected(this.data[0].label);\n        }\n      }\n    }\n  }\n  _handleChange(e) {\n    const el = e.target;\n    this._setSelected(el.value);\n    this.ruxChange.emit(el.value);\n  }\n  connectedCallback() {\n    this._handleChange = this._handleChange.bind(this);\n    const initialSelection = this.data.find((segment) => segment.selected) || this.data[0];\n    if (initialSelection) {\n      this._setSelected(initialSelection.label);\n    }\n  }\n  _setSelected(label) {\n    this.data.map((item) => {\n      item.selected = item.label === label;\n    });\n    this.selected = label;\n  }\n  _slugify(label) {\n    label = label.replace(/^\\s+|\\s+$/g, ''); // trim\n    label = label.toLowerCase();\n    label = label\n      .replace(/[^a-z0-9 -]/g, '') // remove invalid chars\n      .replace(/\\s+/g, '-') // collapse whitespace and replace by -\n      .replace(/-+/g, '-'); // collapse dashes\n    return label;\n  }\n  _isSelected(label) {\n    if (this.selected === label) {\n      return true;\n    }\n    const selectedData = this.data.find((item) => item.label === label);\n    if (selectedData && selectedData.selected) {\n      return true;\n    }\n    return false;\n  }\n  render() {\n    return (h(\"ul\", { class: \"rux-segmented-button\" }, this.data.map((item) => (h(\"li\", { class: \"rux-segmented-button__segment\" }, h(\"input\", { type: \"radio\", name: \"rux-group\", id: this._slugify(item.label), value: item.label, checked: this._isSelected(item.label), \"data-label\": item.label, onChange: this._handleChange }), h(\"label\", { htmlFor: this._slugify(item.label) }, item.label))))));\n  }\n  get el() { return getElement(this); }\n  static get watchers() { return {\n    \"data\": [\"onDataChange\"]\n  }; }\n};\nRuxSegmentedButton.style = ruxSegmentedButtonCss;\n\nexport { RuxSegmentedButton as rux_segmented_button };\n"],"names":[],"sourceRoot":""}