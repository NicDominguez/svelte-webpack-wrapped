{"version":3,"file":"node_modules_astrouxds_astro-web-components_dist_esm_rux-push-button_entry_js.node_modules_astrouxds_astro-web-components_dist_esm_rux-push-button_entry_js.js","mappings":";;;;;;;;;;;;;;;AAA6G;AAChD;;AAE7D,gCAAgC,cAAc,eAAe,iBAAiB,gBAAgB,aAAa,yBAAyB,sBAAsB,qBAAqB,iBAAiB,gBAAgB,+BAA+B,mBAAmB,YAAY,gBAAgB,wBAAwB,+BAA+B,aAAa,uBAAuB,mBAAmB,gBAAgB,0BAA0B,mBAAmB,mBAAmB,iCAAiC,kDAAkD,yCAAyC,8CAA8C,+DAA+D,aAAa,yCAAyC,0DAA0D,kDAAkD,gEAAgE,+BAA+B,mBAAmB;;AAEz9B;AACA;AACA,IAAI,qDAAgB;AACpB,qBAAqB,qDAAW;AAChC,mBAAmB,qDAAW;AAC9B,2CAA2C,KAAK;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sDAAsD;AAClE,IAAI,qDAAiB;AACrB,YAAY,qDAAC,CAAC,iDAAI,IAAI,mBAAmB,QAAQ,4DAA4D,EAAE,qDAAC,YAAY,4KAA4K,GAAG,qDAAC,YAAY,8DAA8D,UAAU,qDAAC;AACjY;AACA,aAAa,OAAO,qDAAU;AAC9B;AACA;AACA;;AAE4C;;;;;;;;;;;;;;;;ACxD5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqD","sources":["webpack://svelte-app/./node_modules/@astrouxds/astro-web-components/dist/esm/rux-push-button.entry.js","webpack://svelte-app/./node_modules/@astrouxds/astro-web-components/dist/esm/utils-0c972f04.js"],"sourcesContent":["import { r as registerInstance, c as createEvent, h, H as Host, g as getElement } from './index-cf8aeed9.js';\nimport { r as renderHiddenInput } from './utils-0c972f04.js';\n\nconst ruxPushButtonCss = \":host{display:block;font-size:16px;height:1.3125rem;line-height:1.7;margin:0 2px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}:host[disabled]{opacity:var(--disabledOpacity);cursor:not-allowed}:host input{appearance:none;-webkit-appearance:none}:host .rux-push-button__button{display:flex;justify-content:center;align-items:center;height:1.375rem;font-size:1rem !important;margin:-27px 0 0 0;padding:0 0.625rem;color:var(--pushbuttonTextColor);background-color:var(--pushbuttonBackgroundColor);border-radius:var(--defaultBorderRadius);border:1px solid var(--pushbuttonBorderColor)}:host .rux-push-button__input:checked+.rux-push-button__button{display:flex;color:var(--pushbuttonSelectedTextColor);background-color:var(--pushbuttonSelectedBackgroundColor);border-color:var(--pushbuttonSelectedBorderColor)}:host .rux-push-button__input:disabled+.rux-push-button__button{opacity:var(--disabledOpacity);cursor:not-allowed}\";\n\nconst RuxPushButton = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.ruxChange = createEvent(this, \"rux-change\", 7);\n    this.ruxBlur = createEvent(this, \"rux-blur\", 7);\n    this.pushButtonId = `rux-push-button-${id++}`;\n    /**\n     * Disables the push button via HTML `disabled` attribute.\n     * Button takes on a distinct disabled visual state.\n     * Cursor uses the `not-allowed` system replacement and all keyboard and mouse events are ignored.\n     */\n    this.disabled = false;\n    /**\n     * Checks the push button via HTML `checked` attribute.\n     * Push button takes on a distinct \"enabled\" or \"selected\" visual state.\n     */\n    this.checked = false;\n    /**\n     * The label of the push button.\n     */\n    this.label = 'Push Button';\n    /**\n     * The name of the push button.\n     */\n    this.name = '';\n    /**\n     * The value of the push button.\n     */\n    this.value = '';\n    this._onBlur = () => {\n      this.ruxBlur.emit();\n    };\n  }\n  componentWillLoad() {\n    this._onChange = this._onChange.bind(this);\n  }\n  _onChange(e) {\n    const target = e.target;\n    this.checked = target.checked;\n    this.ruxChange.emit(this.checked);\n  }\n  render() {\n    const { disabled, checked, label, _onChange, value, _onBlur } = this;\n    renderHiddenInput(true, this.el, this.name, this.value ? this.value : 'on', this.disabled, this.checked);\n    return (h(Host, { \"aria-checked\": `${checked}`, \"aria-hidden\": disabled ? 'true' : null, role: \"switch\" }, h(\"input\", { class: \"rux-push-button__input\", id: this.pushButtonId, type: \"checkbox\", disabled: disabled, checked: checked, onChange: _onChange, onBlur: () => _onBlur(), value: value }), h(\"label\", { class: \"rux-push-button__button\", htmlFor: this.pushButtonId }, label), h(\"slot\", null)));\n  }\n  get el() { return getElement(this); }\n};\nlet id = 0;\nRuxPushButton.style = ruxPushButtonCss;\n\nexport { RuxPushButton as rux_push_button };\n","const hasShadowDom = (el) => {\n  return !!el.shadowRoot && !!el.attachShadow;\n};\n/**\n* This method is used to add a hidden input to a host element that contains\n* a Shadow DOM. It does not add the input inside of the Shadow root which\n* allows it to be picked up inside of forms. It should contain the same\n* values as the host element.\n* https://github.com/ionic-team/ionic-framework/blob/ae96563fb3c4612cb8585292b389ee746f5759f7/core/src/utils/helpers.ts#L198\n\n*\n* @param always Add a hidden input even if the container does not use Shadow\n* @param container The element where the input will be added\n* @param name The name of the input\n* @param value The value of the input\n* @param disabled If true, the input is disabled\n* @param checked Optional. If true, the input is checked\n*/\nconst renderHiddenInput = (always, container, name, value, disabled, checked) => {\n  let input = container.querySelector('input.aux-input');\n  if (always || hasShadowDom(container)) {\n    if (checked || checked == undefined) {\n      if (!input) {\n        input = container.ownerDocument.createElement('input');\n        input.type = 'hidden';\n        input.classList.add('aux-input');\n        container.appendChild(input);\n      }\n      input.disabled = disabled;\n      input.name = name;\n      input.value = value || '';\n    }\n    else {\n      if (input) {\n        input.remove();\n      }\n    }\n  }\n};\n\nexport { hasShadowDom as h, renderHiddenInput as r };\n"],"names":[],"sourceRoot":""}