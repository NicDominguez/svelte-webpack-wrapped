{"version":3,"file":"node_modules_astrouxds_astro-web-components_dist_esm_rux-pop-up-menu_entry_js.node_modules_astrouxds_astro-web-components_dist_esm_rux-pop-up-menu_entry_js.js","mappings":";;;;;;;;;;;;;;AAA6G;;AAE7G,+BAA+B,cAAc,gBAAgB,qBAAqB,0BAA0B,UAAU,eAAe,SAAS,UAAU,kBAAkB,oBAAoB,gCAAgC,6CAA6C,6CAA6C,qBAAqB,cAAc,yBAAyB,sBAAsB,qBAAqB,iBAAiB,kBAAkB,aAAa,cAAc,oCAAoC,iDAAiD,cAAc,oBAAoB,UAAU,mCAAmC,aAAa,aAAa,cAAc,kBAAkB,UAAU,6BAA6B,0DAA0D,2BAA2B,eAAe,GAAG,kBAAkB,gBAAgB,UAAU,SAAS,iDAAiD,UAAU,kBAAkB,gBAAgB,YAAY,0BAA0B,iBAAiB,YAAY,0BAA0B,iBAAiB,qBAAqB,wBAAwB,wBAAwB,UAAU,aAAa,yBAAyB;;AAE9rC;AACA;AACA,IAAI,qDAAgB;AACpB,2BAA2B,qDAAW;AACtC,4BAA4B,qDAAW;AACvC,0BAA0B,qDAAW;AACrC,2BAA2B,qDAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,WAAW;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,KAAK;AACnC,6BAA6B,IAAI;AACjC,kDAAkD,UAAU;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qDAAC,CAAC,iDAAI,IAAI,8CAA8C,EAAE,qDAAC,SAAS,kCAAkC,UAAU,GAAG,EAAE,qDAAC,iBAAiB,qDAAC,WAAW,kBAAkB;AACjL;AACA,aAAa,OAAO,qDAAU;AAC9B,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAE2C","sources":["webpack://svelte-app/./node_modules/@astrouxds/astro-web-components/dist/esm/rux-pop-up-menu.entry.js"],"sourcesContent":["import { r as registerInstance, c as createEvent, h, H as Host, g as getElement } from './index-cf8aeed9.js';\n\nconst ruxPopUpMenuCss = \":host{display:block;--caretLeft:2px;--caretSize:1.875rem;--transitionSpeed:0.1667s;opacity:0;font-size:1rem;margin:0;padding:0;position:absolute;pointer-events:none;color:var(--popupMenuTextColor);background-color:var(--popupMenuBorderColor);border:1px solid var(--popupMenuBorderColor);border-top-width:4px;z-index:10000;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border-radius:3px;top:-9999rem;left:-9999rem;transition:opacity 0.1667s ease-out;filter:drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5))}:host([open]){pointer-events:auto;opacity:1;transition:opacity 0.1667s ease-in}:host::after{content:\\\"\\\";display:block;position:absolute;z-index:1;border:8px solid transparent;border-bottom:11px solid var(--popupCaretBackgroundColor);left:var(--caretLeft, 2px);top:-1.4375rem}ul{position:relative;list-style:none;padding:0;margin:0;background-color:var(--popupMenuBackgroundColor);z-index:2;border-radius:2px}li:last-of-type{border:none;border-radius:0 0 2px 2px}li:first-of-type{border:none;border-radius:2px 2px 0 0}:host(.from-top){border-top-width:1px;border-bottom-width:4px}:host(.from-top)::after{top:unset;bottom:-23px;transform:rotate(180deg)}\";\n\nconst RuxPopUpMenu = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.ruxMenuWillOpen = createEvent(this, \"rux-menu-will-open\", 7);\n    this.ruxMenuWillClose = createEvent(this, \"rux-menu-will-close\", 7);\n    this.ruxMenuDidOpen = createEvent(this, \"rux-menu-did-open\", 7);\n    this.ruxMenuDidClose = createEvent(this, \"rux-menu-did-close\", 7);\n    /**\n     * Boolean which controls when to show the menu\n     */\n    this.open = false;\n  }\n  tieElements() {\n    this._bindElements();\n  }\n  openMenu() {\n    this._toggleOpenClose();\n  }\n  componentDidRender() {\n    if (this.open)\n      this._setMenuPosition();\n  }\n  connectedCallback() {\n    this._handleClick = this._handleClick.bind(this);\n    this._handleOutsideClick = this._handleOutsideClick.bind(this);\n    this._bindElements();\n    this._toggleOpenClose();\n  }\n  disconnectedCallback() {\n    if (this.triggerEl) {\n      this.triggerEl.removeEventListener('mousedown', this._handleClick);\n    }\n  }\n  /**\n   * Returns 'true' if the menu is open, 'false' if it is not.\n   */\n  async isOpen() {\n    return this.open;\n  }\n  /**\n   * Opens the menu. If the menu is already open it returns 'false'.\n   */\n  async show() {\n    if (this.open) {\n      return false;\n    }\n    this.open = true;\n    return true;\n  }\n  /**\n   * Closes the menu. If the menu is already closed it returns 'false'.\n   */\n  async close() {\n    if (!this.open) {\n      return false;\n    }\n    this.open = false;\n    return true;\n  }\n  /**\n   * Toggles the menu open or close. Will return 'true' on menu open and 'false' on menu close\n   */\n  async toggle() {\n    this.open = !this.open;\n    return this.open;\n  }\n  handleListen() {\n    this.open = false;\n  }\n  _bindElements() {\n    // find and set triggerEl from aria-controls if not given\n    if (!this.triggerEl) {\n      const triggerEl = document.querySelector(`[aria-controls=\"${this.el.id}\"]`);\n      if (triggerEl) {\n        this.triggerEl = triggerEl;\n        this.triggerEl.addEventListener('mousedown', this._handleClick);\n      }\n    }\n    else {\n      this.triggerEl.addEventListener('mousedown', this._handleClick);\n    }\n    // If a trigger element exists but no anchor, assign trigger to anchor\n    if (!this.anchorEl && this.triggerEl) {\n      this.anchorEl = this.triggerEl;\n      this.anchorBounds = this.anchorEl.getBoundingClientRect();\n    }\n    else if (this.anchorEl) {\n      this.anchorBounds = this.anchorEl.getBoundingClientRect();\n    }\n    this.menuBounds = this.el.getBoundingClientRect();\n  }\n  _setMenuPosition() {\n    if (this.anchorEl && this.anchorBounds && this.menuBounds) {\n      let { anchorBounds, menuBounds } = this;\n      anchorBounds = this.anchorEl.getBoundingClientRect();\n      menuBounds = this.el.getBoundingClientRect();\n      const caret = parseInt(getComputedStyle(this.el, ':after').height);\n      let top;\n      let left;\n      let caretLeft;\n      const padding = 8;\n      if (menuBounds.width + anchorBounds.left - padding >\n        window.innerWidth) {\n        left = anchorBounds.right - menuBounds.width;\n        caretLeft = menuBounds.width - 25;\n      }\n      else if (anchorBounds.left - padding > 0) {\n        left = anchorBounds.left - padding;\n        caretLeft = 10;\n      }\n      else {\n        left = padding;\n        caretLeft = 10;\n      }\n      top =\n        anchorBounds.bottom +\n          padding / 2 +\n          19 / 2; /* changed caret ref to 19 for bug fix */\n      if (menuBounds.height + anchorBounds.bottom + padding >\n        window.innerHeight) {\n        top = anchorBounds.top - menuBounds.height - caret;\n        this.el.classList.add('from-top');\n      }\n      else {\n        this.el.classList.remove('from-top');\n      }\n      this.el.style.left = `${left}px`;\n      this.el.style.top = `${top}px`;\n      this.el.style.setProperty('--caretLeft', `${caretLeft}px`);\n    }\n  }\n  _handleClick(e) {\n    e.preventDefault();\n    this.open = true;\n  }\n  _handleOutsideClick(e) {\n    const menuClick = e.composedPath().includes(this.el);\n    if (!menuClick) {\n      this.open = false;\n    }\n  }\n  _toggleOpenClose() {\n    var _a, _b;\n    if (this.open) {\n      if (!this.anchorEl) {\n        this.open = false;\n        console.error('Unable to open pop up menu without an anchor element. See documentation');\n        return;\n      }\n      this.ruxMenuWillOpen.emit();\n      const debounce = setTimeout(() => {\n        window.addEventListener('resize', () => this._setMenuPosition());\n        window.addEventListener('mousedown', this._handleOutsideClick);\n        clearTimeout(debounce);\n      }, 10);\n      (_a = this.triggerEl) === null || _a === void 0 ? void 0 : _a.removeEventListener('mousedown', this._handleClick);\n      this.ruxMenuDidOpen.emit();\n    }\n    else {\n      this.ruxMenuWillClose.emit();\n      window.removeEventListener('mousedown', this._handleOutsideClick);\n      window.removeEventListener('resize', this._setMenuPosition);\n      (_b = this.triggerEl) === null || _b === void 0 ? void 0 : _b.addEventListener('mousedown', this._handleClick);\n      this.ruxMenuDidClose.emit();\n    }\n  }\n  render() {\n    return (h(Host, { \"aria-hidden\": !this.open ? 'true' : 'false' }, h(\"ul\", { role: \"menu\", \"aria-expanded\": `${this.open}` }, h(\"slot\", null)), h(\"slot\", { name: \"menu-end\" })));\n  }\n  get el() { return getElement(this); }\n  static get watchers() { return {\n    \"triggerEl\": [\"tieElements\"],\n    \"anchorEl\": [\"tieElements\"],\n    \"open\": [\"openMenu\"]\n  }; }\n};\nRuxPopUpMenu.style = ruxPopUpMenuCss;\n\nexport { RuxPopUpMenu as rux_pop_up_menu };\n"],"names":[],"sourceRoot":""}